@node Concepts
@chapter Concepts

@menu
* Units::
@end menu

This section defines a few concepts that are important for the
@sysname{} library and describes how they related to each other.  The
following figure illustrates some of the concepts and their relations:

@float Figure,fig:architecture
@center @image{architecture,15cm}
@caption{Examples of important concepts and their relations for a single
buffer.}
@end float

@table @dfn

@item Buffer

@cindex buffer
A buffer is conceptually a sequence of lines, each of which contains a
sequence of items and zero or more attached cursors.

@sysname{} does not provide an implementation of the buffer concept or
associated protocols.  Instead, it uses the protocols and classes
provided by the cluffer library.

@item Cursor

@cindex cursor
A cursor is an object that is attached to a buffer line before this
first item, after the last item or between to adjacent items.

@sysname{} does not provide an implementation of the cursor concept or
associated protocols.  Instead, it uses the protocols and classes
provided by the cluffer library.

@item Point

@cindex point
The @anchor{term-point} @dfn{point} is a distinguished cursor within
each @ref{term-site, site} which specifies the buffer location at which
the next editing operation issued by a user will be performed.

@item Mark

@cindex mark
The @anchor{term-mark} @dfn{mark} is a distinguished cursor within each
@ref{term-site,site} that has multiple purposes:
@itemize
@item
Mark cursors can be used to save buffer locations and return to them
later.

@item
Together with the @ref{term-point,point} cursor, the mark cursor can
specify a region within the buffer on which operations can be performed.
@end itemize

The mark cursor of a site can either @dfn{active} or @dfn{inactive}.

@item Operation

@cindex operation
An @dfn{operation} changes the buffer content and/or state of sites in a
particular way, usually depending on the values of one or more parameters.

For example, the @t{move} operation changes the buffer positions of the
point cursors of all sites according to the specified @var{unit} and
@var{direction} arguments.

@item Unit

@cindex unit
@anchor{term-unit} @dfn{Units} are a way to designate particular
sub-sequences of the sequence of all items in a buffer, often relative
to the @ref{term-point,point} cursor.  For example, the @t{word} unit
refers to a sequence of non-whitespace, non-punctuation characters that
follow (or precede depending on the specified direction) the point
cursor.

@item Site

@cindex site
A @anchor{term-site} @dfn{site} ties together pieces of data that are
required for performing consecutive editing operations around a specific
``location'', or site, in a buffer.  The most important piece of data is
the @ref{term-point,point} cursor which makes precise the notion of a
buffer ``location''.  Other pieces of data include the ``preferred''
column of the point cursor, an optional @ref{term-mark,mark} cursor, a
mark stack and an insertion stack.

The main reason for storing this data in a dedicated site object instead
of directly in a buffer is the possibility of allowing simultaneous
editing at multiple sites in a buffer.  From the perspective of an
editor user, each site would typically appear as a cursor (with its own
point, mark, insertion stack, etc.) which would generally act as if it
were the only cursor in the buffer (disregarding effects that arise from
sites being too close together or overlapping).

Each buffer has exactly one @dfn{primary} site and zero or more
@dfn{secondary} sites.  Secondary sites are added and removed by certain
operation.  A secondary site and the primary site can switch roles since
the invariant the associated buffer has to have exactly one primary site
is preserved by that operation.

@item Mark Stack

@cindex mark stack
A @anchor{term-mark-stack} @dfn{mark stack} is a stack which contains
former mark cursors of a @ref{term-site,site}.  Typical operations on
the mark stack include pushing a mark cursor that corresponds to the
location of the point cursor onto the mark stack and later popping the
entry ``into'' the point cursor.  This combination of operations allows
remembering buffer locations and returning to them later.

@item Insertion Stack

@cindex insertion stack
The @anchor{term-insertion-stack} @dfn{insertion stack} is a stack the
elements of which are recently copied or killed sequences of buffer
items which can be inserted into a buffer.  ``Kill'' and ``yank''
operations push to and pop from this stack.

This concept is similar to the ``Kill Ring'' in Emacs with the following
differences:

@itemize

@item As the name suggests, the Emacs kill ring can grow to a maximum
number of items after which it will start discarding the least recent
elements.  In practice however, Emacs is often configured to keep a
practically unlimited number of kill ring elements.  The insertion stack
is unlimited by default.

@item The Emacs kill ring is global by default and has to be restricted
to a local context for extended functionality like editing with multiple
cursors.  In contrast, each insertion stack is local to a specific site
by default.

@end itemize

@end table

@node Units
@section Units

@menu
* Built-in Units::
@end menu

Sites, units and operations are the basic concepts from which most
desired behaviors can be constructed.  Here are a few examples:

@multitable @columnfractions .15 .15 .15 .15 .4
@headitem Operation @tab Unit @tab Direction   @tab Arguments    @tab Equivalent Emacs command
@item     move        @tab item @tab forward   @tab              @tab @t{forward-char}                (@kbd{C-f})
@item     move        @tab item @tab backward  @tab              @tab @t{backward-char}               (@kbd{C-b})
@item     move        @tab word @tab forward   @tab              @tab @t{forward-word}                (@kbd{M-f})
@item     move        @tab word @tab backward  @tab              @tab @t{backward-word}               (@kbd{M-b})
@item     move        @tab line @tab forward   @tab              @tab @t{next-line}                   (@kbd{C-n})
@item     move        @tab line @tab backward  @tab              @tab @t{previous-line}               (@kbd{C-p})

@item     delete      @tab item @tab forward   @tab              @tab @t{delete-char}                 (@kbd{C-d})
@item     delete      @tab item @tab backward  @tab              @tab @t{delete-backward-char}        (@kbd{<backspace>})
@item     delete      @tab word @tab forward   @tab              @tab @t{kill-word}                   (@kbd{M-d})
@item     delete      @tab word @tab backward  @tab              @tab @t{backward-kill-word}          (@kbd{M-<backspace>})
@item     delete      @tab line @tab forward   @tab              @tab @t{kill-line}                   (@kbd{C-k})
@item     delete      @tab line @tab backward  @tab              @tab @t{kill-line} with @t{0} prefix (@kbd{C-0 C-k})

@item     change-case @tab word @tab forward   @tab @t{:capital} @tab @t{capitalize-word}             (@kbd{M-c})
@end multitable

The key observation is that operations, units and directions are mostly
orthogonal.  In other words, new operations and units that are defined
independently should still work together just fine in most cases.  This
relative independence is achieved via the
@ref{Generic-Function text.editing|apply-from-cursor, apply-from-cursor function}
which applies a given item-wise operation to a sub-sequence of buffer
items specified as a unit and a direction.

@include generated-builtin-units.texi
